```
[5장 실습]

수정: 
2023.4.5 16:10
          6번 문제 출력결과 부분 설명 보완

2023.4.5 11:10
          12번 문제 복사생성자 관련 설명 추가

2023.3.30 17:10
          10번 문제의 소스코드에 아래 문장을 추가하였음
          cout << "---" << endl;
          위 문제를 지적해 준 한인혁 학생에게 감사드립니다.

/******************************************************************************
 * 코드 추가 1
 ******************************************************************************/
// 1) 메뉴 [File]->[New]->[C/C++ Project] 한 후 새로운 프로젝트 CH5을 만들어라.
// 2) 메뉴 [File]->[New]->[Source Folder] 한 후 폴더 이름으로 src를 지정하여 생성하라.
// 3) 메뉴 [File]->[New]->[Source File]   한 후 폴더 이름으로는 위에서 지정한 CH5/src로 
//    설정하고 파일 이름으로 ch5.cpp를 지정하여 소스파일을 만들어라.
// 4) 아래 코드를 소스파일로 복사하라.
//-----------------------------------------------------------------------------

===============================================================================
== 프로그램 복사
=============================================================================== 

#include < iostream >
#include < string >

using namespace std;

/******************************************************************************
 * Person Container
 ******************************************************************************/

class Container {
    string title;  // 컨테이너 타이틀
    int    size;   // 컨테이너에 저장된 정수 배열 arr의 크기
    int    *arr;   // size 개의 원소를 가진 배열 시작 주소
public:
    Container();
    Container(string title);
    Container(string title, int size);
    ~Container();

    void setTitle(string title);
    string getTitle();
    void printIntArray();
    void newIntArray();
    void inputIntArray();
};

Container::Container() { }

Container::Container(string title) { }

Container::Container(string title, int size) {
    arr = nullptr; this->size = 0; // 추후 수정할 것
    cout << "Container(): "; printIntArray();
}

Container::~Container() {
    cout << "~Container(): "; printIntArray();
    if (arr != nullptr)
        delete [] arr;
}

void Container::setTitle(string title) {
    this->title = title;
}

string Container::getTitle() {
    return title;
}

void Container::printIntArray() {
    cout << title << ": arr[" << size << "]: ";
    for (int i = 0; i < size; ++i)
    	cout << arr[i] << " ";
    cout << endl;
}

void Container::newIntArray() {
    if (arr != nullptr)
        delete [] arr;
    cout << "element numbers of int array[]? ";
    cin >> size;
    arr = new int[size];
}

void Container::inputIntArray() {
    cout << "input " << size << " integers: ";
    for (int i = 0; i < size; ++i)
        cin >> arr[i];
}

/******************************************************************************
 * Global functions
 ******************************************************************************/

void refParam() {
    Container c("C", 3);
}

void refRet1() {
}

void refRet2() {
}

void explicitCopy() {
}

void implicitCopy() {
}

string menuStr =
"****************************** Main Menu ******************************\n"
"* 0.Exit 1.refParam 2.refRet1 3.refRet2 4.explicitCopy 5.implicitCopy *\n"
"***********************************************************************\n";

int main() {
    while (true) {
        int menuItem;
        cout << endl << menuStr << "menu? ";
        cin >> menuItem;
        if (menuItem == 0)
            break;
        switch(menuItem) {
        case 1: refParam();     break;
        case 2: refRet1();      break;
        case 3: refRet2();      break;
        case 4: explicitCopy(); break;
        case 5: implicitCopy(); break;
        }
    }
    cout << "Good bye!!" << endl;
}


===============================================================================
== 프로그램 실행결과
=============================================================================== 

****************************** Main Menu ******************************
* 0.Exit 1.refParam 2.refRet1 3.refRet2 4.explicitCopy 5.implicitCopy *
***********************************************************************
menu? 1
Container(): : arr[0]: 
~Container(): : arr[0]: 

****************************** Main Menu ******************************
* 0.Exit 1.refParam 2.refRet1 3.refRet2 4.explicitCopy 5.implicitCopy *
***********************************************************************
menu? 0
Good bye!!

===============================================================================
== 문제 1
=============================================================================== 
// 아래 [실행결과 1]처럼 출력되게 Container(string title, int size) 생성자를 수정하라.
// 이 생성자는 클래스 멤버 title과 size를 각각 상응하는 매개변수 값으로 설정한다.
// 그런 후 size 개수가 0보다 클 경우 int형 배열 메모리를 할당받아 arr에 저장하고, 
//       그렇지 않은 경우 arr을 nullptr로 초기화한다.
// 그리고 arr[]의 모든 원소 값을 0으로 초기화한다.

===============================================================================
== 실행결과 1
=============================================================================== 

****************************** Main Menu ******************************
* 0.Exit 1.refParam 2.refRet1 3.refRet2 4.explicitCopy 5.implicitCopy *
***********************************************************************
menu? 1
Container(): C: arr[3]: 0 0 0
~Container(): C: arr[3]: 0 0 0 

... // 이하 메뉴는 항상 생략

===============================================================================
== 문제 2
=============================================================================== 
// 기존 refParam() 함수 내의 마지막에 아래 문장을 추가하라.
    Container b("B");

// 아래 실행 결과를 참고하여 생성자 Container(string title)를 위임 생성자로 변경하되
// Container(string title, int size)를 타겟 생성자로 하라. 
// 단, Container(string title)의 함수 몸체 { }는 수정하지 마라.

===============================================================================
== 실행결과 2
=============================================================================== 
... // 메뉴는 항상 생략
menu? 1
Container(): C: arr[3]: 0 0 0 
Container(): B: arr[0]: 
~Container(): B: arr[0]: 
~Container(): C: arr[3]: 0 0 0 

===============================================================================
== 문제 3
=============================================================================== 
// 기존 refParam() 함수 내의 마지막에 아래 문장을 추가하라.
    Container a;

// 아래 실행 결과를 참고하여 생성자 Container()를 위임 생성자로 변경하되
// Container(string title)를 타겟 생성자로 하라. 
// 단, Container()의 함수 몸체 { }는 수정하지 마라.

===============================================================================
== 실행결과 3
=============================================================================== 
menu? 1
Container(): C: arr[3]: 0 0 0 
Container(): B: arr[0]: 
Container(): no-title: arr[0]: 
~Container(): no-title: arr[0]: 
~Container(): B: arr[0]: 
~Container(): C: arr[3]: 0 0 0 

===============================================================================
== 문제 4
=============================================================================== 
// 기존 refParam() 함수 위쪽에 아래 함수를 추가하라.
//-----------------------------------------------------------------------------
void skipEnter() {
    string s;
    getline(cin, s); // 메뉴항목 번호 뒤의 [엔터]를 제거함
}

//-----------------------------------------------------------------------------
// 기존 refParam() 함수 내의 마지막에 아래 문장들을 추가하라.
    Container d;
    skipEnter();
    inputTitle(d);

//-----------------------------------------------------------------------------
// 아래 실행 결과를 참고하여 void inputTitle(d) 함수를 구현하라.
// 이 함수의 리턴 타입은 void이다.
// 이 함수의 매개변수는 Container형의 참조 매개변수로 선언하라.
// 이 함수는 사용자로부터 새로운 타이틀을 입력받아 참조 매개변수 객체의 title 멤버 값을 
// 입력받은 새 타이틀로 변경한다. 
// 구현 시 아래 [문제 5] changeTitle() 코드 참고할 것
// 주지: 함수가 리턴해도 inputTitle(d) 함수에서 설정한 새로운 타이틀 값으로
//      실인자 객체 d의 title 멤버의 값이 변경되어 있음을 확인할 수 있는데,
//      이는 함수 리턴 후 객체 d의 소멸자 함수 실행 결과에서 확인할 수 있다.

===============================================================================
== 실행결과 4
=============================================================================== 
menu? 1
Container(): C: arr[3]: 0 0 0 
Container(): B: arr[0]: 
Container(): no-title: arr[0]: 
Container(): no-title: arr[0]: 
input title: D E F
~Container(): D E F: arr[0]: 
~Container(): no-title: arr[0]: 
~Container(): B: arr[0]: 
~Container(): C: arr[3]: 0 0 0 

===============================================================================
== 문제 5
=============================================================================== 
// 기존 refRet1() 함수 위쪽에 아래 함수를 추가하라.
//-----------------------------------------------------------------------------
Container& changeTitle(Container& rc) {
    string s;
    cout << "title to change: ";
    getline(cin, s);
    rc.setTitle(s);
    return rc;       // rc의 원본 객체의 참조를 리턴함
}

//-----------------------------------------------------------------------------
// 기존 refRet1() 함수에 아래 문장들을 추가하라.
//-----------------------------------------------------------------------------
void refRet1() {
    skipEnter();
    Container c("C");
    Container& rc = changeTitle(c); // rc는 원본 객체 c의 데이타를 공유하는 참조변수임
    cout << " c.getTitle(): " <<  c.getTitle() << endl;
    cout << "rc.getTitle(): " << rc.getTitle() << endl;
}

===============================================================================
== 실행결과 5
=============================================================================== 
menu? 2
Container(): C: arr[0]: 
title to change: CC
 c.getTitle(): CC
rc.getTitle(): CC
~Container(): CC: arr[0]: 

===============================================================================
== 문제 6
=============================================================================== 
// 기존 refRet1() 함수 내의 마지막에 아래 문장들을 추가하라.
//-----------------------------------------------------------------------------
    cout << "---" << endl;
    cout << "appendTitle(c).getTitle(): " << changeTitle(rc).getTitle() << endl;
    cout << "             c.getTitle(): " <<               c.getTitle() << endl;
    cout << "            rc.getTitle(): " <<              rc.getTitle() << endl;
    // changeTitle(rc)에 의해 반환되는 참조 역시 원본 객체 c의 데이타를 공유하는 참조변수임
    // 참조 변수는 생성자 및 소멸자가 없다. 원본 객체의 데이터를 공유하는 또 다른 변수 이름일 뿐이다.

===============================================================================
== 실행결과 6
=============================================================================== 
menu? 2
Container(): C: arr[0]: 
title to change: CC
 c.getTitle(): CC
rc.getTitle(): CC
---
title to change: CCC
appendTitle(c).getTitle(): CCC
             c.getTitle(): CCC
            rc.getTitle(): CCC
~Container(): CCC: arr[0]: 

//---------------------------------------
// 위 출력 결과에서 "title to change: "와 "appendTitle(c).getTitle(): "의 출력 순서가
// 경우에 따라서 순서가 바뀌어 출력될 수 있음. 제출하는데는 문제가 없음

===============================================================================
== 문제 7
=============================================================================== 
// 기존 refRet2() 함수에 아래 문장들을 추가하라.
//-----------------------------------------------------------------------------
void refRet2() {
    Container c("C");
    c.newIntArray().inputIntArray().printIntArray();
}

//-----------------------------------------------------------------------------
// 아래와 같은 출력결과가 나올 수 있도록 Container 클래스의 두 멤버함수
// newIntArray()와 inputIntArray()의 리턴 데이타 타입을 변경하고 적절한 값을 리턴하라.
// 이 두 함수는 현재 Container 객체의 참조자를 반환한다.
// 위 코드에서 newIntArray()와 inputIntArray()는 c의 참조 값을 반환한다.
// 강의노트의 class Calculator를 참고하라. 

// 위 c.newIntArray().inputIntArray() 코드에서 두 함수의 리턴 값은 모두 c 객체와 
// 데이타를 공유하는 새로운 참조를 반환하지만 결국은 객체 c를 의미하는 것이다.

===============================================================================
== 실행결과 7
=============================================================================== 
menu? 3
Container(): C: arr[0]: 
element numbers of int array[]? 3      // c.newIntArray()의 실행결과
input 3 integers: 1 2 3                // c.inputIntArray()의 실행결과
C: arr[3]: 1 2 3                       // c.printIntArray()의 실행결과
~Container(): C: arr[3]: 1 2 3 

===============================================================================
== 문제 8
=============================================================================== 
// 기존 explicitCopy() 함수에 아래 문장들을 추가하라.
//-----------------------------------------------------------------------------
void explicitCopy() {
    Container c1("c1", 4);
    c1.inputIntArray().printIntArray();
    cout << "---" << endl;
    Container c2(c1);
    c2.setTitle("c2");
    c2.printIntArray();
    cout << "---" << endl;
    c2.inputIntArray().printIntArray();
    c1.printIntArray();
}

//-----------------------------------------------------------------------------
// 위 코드에서 Container c2(c1);에서 디폴트 복사생성자가 수행된다. (얕은 복사)
// 즉 c1의 각 멤버를 상응하는 c2 멤버로 1:1로 복사한다.
// 이때 멤버가 arr 멤버처럼 동적으로 할당받은 메모리 주소를 가지고 있을 경우
// c1과 c2의 arr 멤버는 동일한 메모리를 공유하게 된다.

// 이 경우 explicitCopy()가 리턴할 때 c2의 소멸자가 먼저 실행되어 arr 메모리를 반납한다.
// 그런 후 c1의 소멸자가 실행되면서 이미 반납된 arr 메모리를 또 반납한다.
// 이 과정에서 오류가 발생하게 된다. 

// 아래 실행결과에서 c2의 arr 내용을 변경했는데 c1의 arr도 같이 변경된다. (얕은 복사 때문)
// 또한 c1이 소멸될 때 이미 arr의 내용이 변경되어 있는 것을 볼 수 있다.
// 이는 c2가 먼저 소멸되면서 arr을 반납했는데 이 과정에서 arr의 내용이 변경되기 때문이다.
// 그 후 c1이 소멸되면서 이미 반납된 arr 메모리를 또 반납하는 문제가 발생하게 된다.

===============================================================================
== 실행결과 8
=============================================================================== 
menu? 4
Container(): c1: arr[4]: 0 0 0 0 
input 4 integers: 1 2 3 4
c1: arr[4]: 1 2 3 4 
---
c2: arr[4]: 1 2 3 4 
---
input 4 integers: 5 6 7 8
c2: arr[4]: 5 6 7 8 
c1: arr[4]: 5 6 7 8 
~Container(): c2: arr[4]: 5 6 7 8 
~Container(): c1: arr[4]: 15895552 15859904 7 8 

===============================================================================
== 문제 9
=============================================================================== 
// 위 문제를 해결하기 위해 클래스 Container에 깊은 복사를 수행하는 복사생성자를 추가하라.

// 복사생성자는 매개변수 객체(원본 객체)의 title, size를 상응하는 멤버에 저장하고
// size가 0보다 클경우 size개의 배열 메모리를 동적으로 할당받아 arr에 저장하고
                  원본 객체의 arr[]의 모든 원소를 복사한다.
// size가 0보다 크지 않을 경우 nullptr를 arr에 저장한다. 
// 마지막에 아래 문장을 추가한다.
    cout << "Container(Container& c): "; printIntArray();

// 아래 실행결과에서 c1, c2의 arr[]의 내용이 서로 다름을 확인할 수 있다.
// 이는 깊은 복사가 수행되었음을 의미한다.

===============================================================================
== 실행결과 9
=============================================================================== 
menu? 4
Container(): c1: arr[4]: 0 0 0 0 
input 4 integers: 1 2 3 4
c1: arr[4]: 1 2 3 4 
---
Container(Container& c): c1: arr[4]: 1 2 3 4 
c2: arr[4]: 1 2 3 4 
---
input 4 integers: 5 6 7 8
c2: arr[4]: 5 6 7 8 
c1: arr[4]: 1 2 3 4 
~Container(): c2: arr[4]: 5 6 7 8 
~Container(): c1: arr[4]: 1 2 3 4 

===============================================================================
== 문제 10
=============================================================================== 
// 이 이후의 문제들에서 복사생성자가 언제 자동으로 실행되지를 각 경우에 대해 확인해 보길 바란다.
//-----------------------------------------------------------------------------
// 기존 implicitCopy() 함수에 아래 문장들을 추가하라.
//-----------------------------------------------------------------------------
void implicitCopy() {
    Container a("A", 2);
    a.inputIntArray().printIntArray();
    cout << "---" << endl;
    Container b = a; // 자동으로 복사생성자 호출
    b.setTitle("B");
    b.inputIntArray().printIntArray();
    cout << "---" << endl;
}

//-----------------------------------------------------------------------------
// 아래 실행결과에서 Container b = a; 실행시 자동으로 복사생성자가 실행됨을 확인할 수 있다.

===============================================================================
== 실행결과 10
=============================================================================== 
menu? 5
Container(): A: arr[2]: 0 0 
input 2 integers: 1 2
A: arr[2]: 1 2 
---
Container(Container& c): A: arr[2]: 1 2 
input 2 integers: 3 4
B: arr[2]: 3 4 
---
~Container(): B: arr[2]: 3 4 
~Container(): A: arr[2]: 1 2 

===============================================================================
== 문제 11
=============================================================================== 
// 기존 implicitCopy() 함수 위쪽에 아래 함수를 추가하라.
//-----------------------------------------------------------------------------
void callByValue(Container v) {
    cout << "callByValue" << endl;
    v.setTitle("V");
    v.inputIntArray().printIntArray();
}

//-----------------------------------------------------------------------------// // 기존 implicitCopy() 함수 내의 마지막에 아래 문장들을 추가하라.
//-----------------------------------------------------------------------------
    callByValue(a); // 자동으로 복사생성자 호출
    cout << "---" << endl;

//-----------------------------------------------------------------------------
// 아래 실행결과에서 callByValue(a); 실행시 
// 실 객체 a를 함수의 매개변수 v로 복사하기 위해 자동으로 복사생성자가 실행됨을 확인할 수 있다.
// 값에 의한 호출이므로 이 함수의 실행으로 실 객체 a는 전혀 영향을 받지 않는다.
// 함수 리턴 시 매개변수 객체 v는 소멸된다.

===============================================================================
== 실행결과 11
=============================================================================== 
menu? 5
Container(): A: arr[2]: 0 0 
input 2 integers: 1 2
A: arr[2]: 1 2 
---
Container(Container& c): A: arr[2]: 1 2 
input 2 integers: 3 4
B: arr[2]: 3 4 
---
Container(Container& c): A: arr[2]: 1 2 
callByValue
input 2 integers: 5 6
V: arr[2]: 5 6 
~Container(): V: arr[2]: 5 6 
---
~Container(): B: arr[2]: 3 4 
~Container(): A: arr[2]: 1 2 

===============================================================================
== 문제 12
=============================================================================== 
// 기존 implicitCopy() 함수 위쪽에 아래 함수를 추가하라.
//-----------------------------------------------------------------------------
Container returnValue(Container& r) {
    cout << "returnValue" << endl;
    return r;  // 자동으로 복사생성자 호출
}

//-----------------------------------------------------------------------------// 
// 기존 implicitCopy() 함수 내의 마지막에 아래 문장들을 추가하라.
//-----------------------------------------------------------------------------
    Container c = returnValue(a);
    c.setTitle("C");
    c.inputIntArray().printIntArray();
    cout << "---" << endl;

//-----------------------------------------------------------------------------
// 아래 실행결과에서 returnValue(a); 함수 호출 시 매개변수가 참조변수이므로 
// 객체의 참조만 전달되므로 복사생성자가 호출되지 않음을 확인할 수 있다.
// 그러나 returnValue(Container& r) 함수의 리턴 시 리턴 값이 객체이므로
// 자동으로 복사생성자가 실행되어 객체가 복사되어 반환되는 것을 확인할 수 있다.
// 주의: Container의 복사생성자의 매개변수 선언 시 
//       반드시 const가 들어가야 에러가 발생하지 않음 Container(const Container& c)

===============================================================================
== 실행결과 12
=============================================================================== 
menu? 5
Container(): A: arr[2]: 0 0 
input 2 integers: 1 2
A: arr[2]: 1 2 
---
Container(Container& c): A: arr[2]: 1 2 
input 2 integers: 3 4
B: arr[2]: 3 4 
---
Container(Container& c): A: arr[2]: 1 2 
callByValue
input 2 integers: 5 6
V: arr[2]: 5 6 
~Container(): V: arr[2]: 5 6 
---
returnValue
Container(Container& c): A: arr[2]: 1 2 
input 2 integers: 7 8
C: arr[2]: 7 8 
---
~Container(): C: arr[2]: 7 8 
~Container(): B: arr[2]: 3 4 
~Container(): A: arr[2]: 1 2 
```